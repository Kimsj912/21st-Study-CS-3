# 4.5 지속 커넥션

웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺는다. 서버에 HTTP 요청을 하기 시작한 애플리케이션은 해당 페이지 내의 이미지 등 리소스를 가져오기 위해 그 서버에 또 요청하게 된다. 그리고 이것을 **사이트 지역성(site locality)**라 부른다.

따라서 HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다. 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 **지속 커넥션**이라고 부른다. 비지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을 직접 끊지 않는 이상 트랜잭션 간에도 커넥션을 유지한다.

해당 서버에 이미 맺어져 있는 지속 커넥션을 재사용함으로써, **커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있다.** 커넥션이 이미 맺어져 있다면, TCP 특성상 맺어지는 과정이 매우 느린데 이러한 부분들을 피함으로써 더 빠른 데이터 전송을 할 수 있다.

<br />
<br />

## 4.5.1 지속 커넥션 vs 병렬 커넥션

#### 병렬 커넥션의 단점

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 **시간과 대역폭이 소요됨** <br />
- 각각의 새로운 커넥션은 **느린 TCP 때문에 성능이 떨어진다.** <br />
- 실제로 연결할 수 있는 **병렬 커넥션의 수는 제한이 있다.**

<br />

#### 지속 커넥션의 장점

- 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여준다. <br />
  - 하지만 잘못 관리했을 경우, 수많은 커넥션이 연결된 상태로 있을 것이다.
  - 이로 인해, 클라이언트와 서버의 불필요한 소모가 발생한다.

그렇다면 지속 커넥션만 사용을 해야 하는가? 그렇지 않다. 지속 커넥션과 병렬 커넥션을 함께 사용할 때 가장 효과적이다. 오늘날 많은 웹은 적은 수의 병렬 커넥션만 맺고 그것을 유지한다. 그리고 두 가지 지속 커넥션이 있는데, HTTP/1.0+ 에는 'keep-alive' 커넥션이 있고, HTTP/1.1에는 '지속' 커넥션이 있다.

<br />
<br />

## 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

많은 클라이언트는 초기에 상호 운용과 설게 문제가 많은 keep-alive 커넥션을 사용하고 있었다. 하지만 그러한 문제들은 HTTP/1.1에서 다 수정되었다.

(그림 첨부 예정)

<br />
<br />

## 4.5.3 Keep-Alive 동작

keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌다. 하지만 아직도 브라우저와 서버간에 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에, HTTP 애플리케이션은 그것들을 처리할 수 있게 개발해야 한다.

이제 Keep-alive의 동작 방식을 살펴보면, HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 **Connection:Keep-Alive** 포함시켜야 한다. 이 요청을 받은 서버는 그다음 요청에도 이 커넥션을 받고자 한다면, 응답 메시지에 같은 헤더를 포함시키기만 하면 된다. 응답에 **Connection:Keep-Alive** 헤더가 없으면, 클라이언트는 keep-alive를 지원하지 않으며, 응답 메시지가 전송되고 나면 알아서 서버 커넥션을 끊을 것이라고 인지한다.

(그림 첨부 예정)

<br />
<br />

## 4.5.4 Keep-Alive 옵션

**Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다.** 서버나 클라이언트가 keep-alive 요청을 받았다고 해서 **무조건 그것을 따를 필요는 없다.** 언제든지 현재의 keep-alive 커넥션을 끊을 수 있으며, 이 커넥션에서 처리되는 트랜잭션의 수를 제한할 수도 있다. 그리고 쉼표를 통해 옵션들로 제어할 수도 있다.

- timeout 파라미터는 커넥션이 얼마간 유지될 것인지를 의미 (하지만 이대로 보장 X)
- max 파라미터는 **응답 헤더**를 통해 보냄. 이는 커넥션이 **몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미**

```
// 서버가 5개의 추가 트랜잭션이 처리될 동안 커넥션을 유지하거나,
// 2분 동안 커넥션을 유지하라는 내용

Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

<br />
<br />

## 4.5.5 Keep-Alive 커넥션 제한과 규칙

- keep-alive는 HTTP/1.0에서 기본으로 사용되지 않는다. **Connection:Keep-Alive**를 포함시켜야 한다.
- **Connection:Keep-Alive** 헤더를 보내지 않으면 서버는 요청을 처리한 후 커넥션을 끊을 것이다.
- 클라이언트는 **Connection:Keep-Alive** 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다.
- 커넥션이 끊어지기 전에 **엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. 정확한 Content-Length 과 Content-Type 또는 청크 전송 인코딩으로 인코드 되어야 한다. 그 이유는 트랜잭션이 끝나는 시점에 **기존 메시지의 끝**과 **새로운 메시지의 시작점**을 정확히 알 수 없기 때문이다.
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. 프락시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더를 제거해야 한다.
- 정석대로라면, keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안된다.
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌다면, 큰 문제가 아니라면 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

<br />
<br />

## 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

#### Connection 헤더의 무조건 전달

특정 문제는 프락시에서 시작되는데, 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다. 오래되고 단순한 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다. 무조건 전달하는 멍청한 프락시가 어떻게 동작하는지 살펴보자.

1. 먼저 클라이언트는 프락시에 **Connection:Keep-Alive** 헤더와 함께 메시지를 보낸다.
2. 멍청한 프락시는 당연히 요청받은 HTTP의 Connection 헤더를 이해하지 못한다. 그대로 서버에게 전달한다. 여기서부터 문제가 시작된다.
3. 서버는 클라이언트로부터 keep-alive 커넥션을 맺자고 요청하는 것으로 판단하게 된다. 웹 서버는 문제될게 없기 때문에 이 커넥션을 유지하게 된다. 그러면 keep-alive 커넥션이 맺어진 상태로 keep-alive 규칙에 맞게 통신을 하도록 판단하게 된다.
4. 멍청한 프락시는 받았던 모든 데이터를 서버에게 전달하고 나서 커넥션이 끊어지기를 기다리게 된다. 하지만 서버는 keep-alive 커넥션을 유지하는 것으로 판단하기 때문에 커넥션을 끊지 않고 계속 커넥션을 유지하려고 한다.
5. 따라서 클라이언트는 요청을 보내고 응답 메시지를 받으면, 다음 요청을 보낼 때 커넥션이 유지되고 있는 프락시에 요청을 보낸다. 프락시는 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에, 해당 요청은 프락시로부터 무시되고 브라우저는 아무런 응답 없이 로드 중 이라는 표시만 나온다.
6. 이런 잘못된 통신 때문에, **브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다.**

<br />

#### 프락시와 홉별 헤더

위와 같은 통신을 피하려면 프락시는 Connection 헤더와 Connection 헤더에 명시된 것들을 전달하면 안된다. 또한 Connection 헤더의 값으로 명시되지 않은 Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade와 같은 홉별 헤더들 역시 전달하거나 캐시하면 안된다.

<br />
<br />

## 4.5.7 Proxy-Connection 살펴보기

넷스케이프의 브라우저 및 프락시 개발자들은 웹 애플리케이션이 HTTP 최신 버전을 지원하지 않아도, 모든 헤더를 무조건 전달하는 문제를 해결하는 차선책을 제시했다. 그 차선책은, 클라이언트의 요청이 중개서버를 통해 이어지는 경우 Proxy-Connection이라는 헤더를 사용하는 것이다. Proxy-Connection은 프락시를 별도로 설정할 수 있는 현대 웹 브라우저에서 지원하며, 많은 프락시들도 이것을 인식한다.

지속 커넥션 핸드셰이킹을 이해할 수 있는 프락시라면 클라이언트로부터 **Proxy-Connection: Keep-Alive** 헤더 요청을 받아도 최종적으로 서버에게는 **Connection:Keep-Alive** 헤더를 웹 서버에게 전송한다. 




