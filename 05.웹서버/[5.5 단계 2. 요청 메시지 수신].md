## 1. 요청 메시지 파싱

- 커넥션에 데이터가 도착하면 웹 서버는 `네트워크 커넥션에서 그 데이터를 읽어들이고 파싱하여 요청 메시지 구성`
- 요청 메시지를 파싱할 때 웹 서버가 하는 일
  - 요청줄을 파싱하여 `요청 메서드, 지정된 리소스의 식별자(URI), 버전번호` 를 찾는다. 각 값은 스페이스 한 개로 분리되어 있으며 요청줄은 캐리지리턴줄바꿈(CRLF) 문자열로 끝난다
  - 메시지 헤더들을 읽는다. 각 메시지 헤더는 CRLF로 끝난다
  - 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다(존재한다면)
  - 요청 본문이 있다면 읽어들인다
- 요청 메시지를 파싱할 때 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받는다
- 네트워크 커넥션은 언제라도 무효화될 수 있기 때문에 웹 서버는 파싱해서 이해하는 것이 가능한 수준의 분량을 확보할 때까지 데이터를 네트워크로부터 읽어서 메시지 일부분을 메모리에 임시로 저장해둘 필요가 있다

## 2. 메세지의 내부 표현(5.5.1)

- 몇몇 웹 서버는 요청 메시지를 쉽게 다룰수 있도록 `내부의 자료구조`에 저장
- 그 자료구조는 요청 메시지의 각 조각에 대한 `포인터와 길이`를 담을 수 있을 것이고, 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근할 수 있을 것이다

## 3. 커넥션 입력/출력 처리 아키텍처(5.5.2)

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원
  - 이 커넥션들은 웹 서버가 전 세계의 클라이언트들과 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 해줌
- 웹 서버들은 항상 새 요청을 주시
  - 요청은 언제라도 도착할 수 있기 때문
- 웹 서버 `아키텍처의 차이`에 따라 요청을 처리하는 방식도 달라진다
  - `단일 스레드 웹 서버`
    - 한 번에 `하나씩` 요청을 처리
    - 트랜잭션이 완료되면 다음 커넥션이 처리된다
    - 구현하기 간단하지만 처리 도중에 `모든 다른 커넥션은 무시`
    - 심각한 `성능 문제`를 만들어내므로 오직 로드가 적은 서버나 type-o-serve 와 같은 진단도구에서만 적당
  - `멀티프로세스와 멀티스레드 웹 서버`
    - 여러 요청을 동시에 처리하기 위해 `여러개의 프로세스 혹은 고효율 스레드`를 할당
    - 스레드/프로세스는 필요할 때마다 만들어질 수도 있고 미리 만들어질 수도 있다
    - 많은 멀티스레드 웹 서비스가 스레드/프로세스의 최대 개수에 제한을 건다
  - `다중 I/O 서버`
    - `대량의 커넥션`을 지원하기 위해 많은 웹 서버가 채택
    - 모든 커넥션은 동시에 그 활동을 감시당한다
    - 커넥션의 상태가 바뀌면(ex 데이터를 사용할 수 있게 되거나 에러가 발생) 그 커넥션에 대해 작은 양의 처리가 수행. 그 처리가 완료되면 커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다
    - 어떤 커넥션에 대해 작업을 수행하는 것은 `그 커넥션에 실제로 해야 할 일이 있을 때`뿐
    - 스레드와 프로세스는 유휴 상태의 커넥션에 매여 기다리느라 리소스를 낭비하지 않는다
  - `다중 멀티스레드 웹 서버`
    - 몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러개의 이점을 살리기 위해 `멀티 스레딩과 다중화 결합`
    - `여러개의 스레드 (보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션(혹은 열려있는 커넥션의 부분집합)을 감시`하고 각 커넥션에 대해 조금씩 작업 수행
